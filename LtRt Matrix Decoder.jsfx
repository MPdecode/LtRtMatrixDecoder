// JSFX plugin hosted at https://github.com/MPdecode/LtRtMatrixDecoder

desc: LtRt Matrix Decoder with Logic Steering

slider1:20<0,50,1>Surround Delay (ms)
Slider2:80<0,200,10>Bass Crossover (Hz)
slider3:200<100,500,10>Control Low Cut (Hz)
slider4:10000<5000,15000,100>Control High Cut (Hz)
slider5:7000<5000,10000,100>Surround Low Pass Filter (Hz)
slider6:0<0,1,1{Full Logic LRCS (5.1), LRC only}>Mode
Slider7:1<0,2,0.1>Steering Strength
slider8:-3<-20,0,1>Output Gain (dB)
slider9:-3<-20,0,1>Surround Level (dB)
slider10:1<0,1,1{Off,On}>Show/Hide GUI

in_pin:Lt
in_pin:Rt
out_pin:FL
out_pin:FR
out_pin:FC
out_pin:LFE
out_pin:LS
out_pin:RS

@init
pi = 2*asin(1);
max_db_base = 30.0;
tau_level = 0.02;
alpha = exp(-1/(tau_level * srate));
beta = 1 - alpha;

attack_tau = 0.005;
alpha_attack = exp(-1/(attack_tau * srate));
beta_attack = 1 - alpha_attack;

gain_out = pow(10, slider8 / 20.0);
surround_level = pow(10, slider9 / 20.0);

// Delay setup
// Dynamically calculate the maximum required delay memory
// based on the slider's max value (50ms) to ensure it works at any sample rate.
max_slider_delay_ms = 50.0;
max_delay_samples = floor(max_slider_delay_ms * 0.001 * srate + 0.5) + 2; // +2 for safety buffer

// Initialize the current delay and memory access
delay_samples = floor(slider1 * 0.001 * srate + 0.5);
delay_pos = 0;

// Start of delay buffer at offset 0 (simple; total pool is 1M slots, so no conflicts)
m = 0;

// Zero the max needed samples (required, as memory may start with garbage)
i = 0;
while (i < max_delay_samples) (
  m[i] = 0;
  i += 1;
);

// Biquad coefficients for bass lowpass
function update_bass_coeffs() local(f, theta, sinth, costh, Q, alphab) (
  f = slider2 / srate;
  theta = 2 * pi * f;
  sinth = sin(theta);
  costh = cos(theta);
  Q = 0.7071;
  alphab = sinth / (2 * Q);
  a0b = (1 - costh) / 2;
  a1b = 1 - costh;
  a2b = (1 - costh) / 2;
  b0b = 1 + alphab;
  a0b /= b0b;
  a1b /= b0b;
  a2b /= b0b;
  b1b = -2 * costh / b0b;
  b2b = (1 - alphab) / b0b;
);
update_bass_coeffs();

// State for bass lowpass L and R
l_low_x1 = l_low_x2 = l_low_y1 = l_low_y2 = 0;
r_low_x1 = r_low_x2 = r_low_y1 = r_low_y2 = 0;

// Biquad for control highpass
function update_hp_coeffs() local(f, theta, sinth, costh, Q, alphah) (
  f = slider3 / srate;
  theta = 2 * pi * f;
  sinth = sin(theta);
  costh = cos(theta);
  Q = 0.7071;
  alphah = sinth / (2 * Q);
  a0h = (1 + costh) / 2;
  a1h = -(1 + costh);
  a2h = (1 + costh) / 2;
  b0h = 1 + alphah;
  a0h /= b0h;
  a1h /= b0h;
  a2h /= b0h;
  b1h = -2 * costh / b0h;
  b2h = (1 - alphah) / b0h;
);
update_hp_coeffs();

// State for highpass L and R
l_hp_x1 = l_hp_x2 = l_hp_y1 = l_hp_y2 = 0;
r_hp_x1 = r_hp_x2 = r_hp_y1 = r_hp_y2 = 0;

// Biquad for control lowpass
function update_lp_coeffs() local(f, theta, sinth, costh, Q, alphac) (
  f = slider4 / srate;
  theta = 2 * pi * f;
  sinth = sin(theta);
  costh = cos(theta);
  Q = 0.7071;
  alphac = sinth / (2 * Q);
  a0c = (1 - costh) / 2;
  a1c = 1 - costh;
  a2c = (1 - costh) / 2;
  b0c = 1 + alphac;
  a0c /= b0c;
  a1c /= b0c;
  a2c /= b0c;
  b1c = -2 * costh / b0c;
  b2c = (1 - alphac) / b0c;
);
update_lp_coeffs();

// State for control lowpass L and R
l_lp_x1 = l_lp_x2 = l_lp_y1 = l_lp_y2 = 0;
r_lp_x1 = r_lp_x2 = r_lp_y1 = r_lp_y2 = 0;

// Biquad for surround lowpass
function update_sur_coeffs() local(f, theta, sinth, costh, Q, alphas) (
  f = slider5 / srate;
  theta = 2 * pi * f;
  sinth = sin(theta);
  costh = cos(theta);
  Q = 0.7071;
  alphas = sinth / (2 * Q);
  a0s = (1 - costh) / 2;
  a1s = 1 - costh;
  a2s = (1 - costh) / 2;
  b0s = 1 + alphas;
  a0s /= b0s;
  a1s /= b0s;
  a2s /= b0s;
  b1s = -2 * costh / b0s;
  b2s = (1 - alphas) / b0s;
);
update_sur_coeffs();

// State for surround lowpass
s_lp_x1 = s_lp_x2 = s_lp_y1 = s_lp_y2 = 0;

// Level vars
l_level = r_level = c_level = s_level = 0.0000000001;

// Smoothed gains
kf_smooth = kb_smooth = kl_smooth = kr_smooth = 0;

// Output level smoothing
tau_out = 0.01;
alpha_out = exp(-1/(tau_out * srate));
beta_out = 1 - alpha_out;
fl_level = fr_level = fc_level = s_level_out = 0.0000000001;

// Soft clip
function softclip(x) local(e) (
  e = exp(2 * x);
  (e - 1) / (e + 1);
);

@slider
update_bass_coeffs();
update_hp_coeffs();
update_lp_coeffs();
update_sur_coeffs();
gain_out = pow(10, slider8 / 20.0);
surround_level = pow(10, slider9 / 20.0);
delay_samples = floor(slider1 * 0.001 * srate + 0.5);

@sample
Lt = spl0;
Rt = spl1;

// Bass lowpass
l_low = a0b * Lt + a1b * l_low_x1 + a2b * l_low_x2 - b1b * l_low_y1 - b2b * l_low_y2;
l_low_x2 = l_low_x1; l_low_x1 = Lt;
l_low_y2 = l_low_y1; l_low_y1 = l_low;

r_low = a0b * Rt + a1b * r_low_x1 + a2b * r_low_x2 - b1b * r_low_y1 - b2b * r_low_y2;
r_low_x2 = r_low_x1; r_low_x1 = Rt;
r_low_y2 = r_low_y1; r_low_y1 = r_low;

// Mid-high
L_mid = Lt - l_low;
R_mid = Rt - r_low;

// Fixed matrix for low
FL_low = l_low;
FR_low = r_low;
FC_low = 0.7071 * (l_low + r_low);
S_low = 0.7071 * (l_low - r_low);

// Control highpass
l_hp = a0h * Lt + a1h * l_hp_x1 + a2h * l_hp_x2 - b1h * l_hp_y1 - b2h * l_hp_y2;
l_hp_x2 = l_hp_x1; l_hp_x1 = Lt;
l_hp_y2 = l_hp_y1; l_hp_y1 = l_hp;

r_hp = a0h * Rt + a1h * r_hp_x1 + a2h * r_hp_x2 - b1h * r_hp_y1 - b2h * r_hp_y2;
r_hp_x2 = r_hp_x1; r_hp_x1 = Rt;
r_hp_y2 = r_hp_y1; r_hp_y1 = r_hp;

// Control lowpass (to complete bandpass)
l_f = a0c * l_hp + a1c * l_lp_x1 + a2c * l_lp_x2 - b1c * l_lp_y1 - b2c * l_lp_y2;
l_lp_x2 = l_lp_x1; l_lp_x1 = l_hp;
l_lp_y2 = l_lp_y1; l_lp_y1 = l_f;

r_f = a0c * r_hp + a1c * r_lp_x1 + a2c * r_lp_x2 - b1c * r_lp_y1 - b2c * r_lp_y2;
r_lp_x2 = r_lp_x1; r_lp_x1 = r_hp;
r_lp_y2 = r_lp_y1; r_lp_y1 = r_f;

// Smoothed levels
l_level = alpha * l_level + beta * abs(l_f);
r_level = alpha * r_level + beta * abs(r_f);
c_level = alpha * c_level + beta * abs(l_f + r_f);
s_level = alpha * s_level + beta * abs(l_f - r_f);

// dB levels
db_l = 20 * log10(l_level + 0.000000000000000000000001);
db_r = 20 * log10(r_level + 0.000000000000000000000001);
db_c = 20 * log10(c_level + 0.000000000000000000000001);
db_s = 20 * log10(s_level + 0.000000000000000000000001);

// Dominance
lr_db = db_l - db_r;
fb_db = db_c - db_s;
strength = max(0.01, slider7);
max_db = max_db_base / strength;
lr_db = max(-max_db, min(max_db, lr_db));
fb_db = max(-max_db, min(max_db, fb_db));

// Adaptive release computation
dominance_strength = max( abs(lr_db), abs(fb_db) ) / max_db;
fast_release_tau = 0.005;  // 5ms for quick transient response
slow_release_tau = 0.2;    // 200ms for ambient stability
release_tau = slow_release_tau - (slow_release_tau - fast_release_tau) * dominance_strength;
alpha_release = exp(-1 / (release_tau * srate));
beta_release = 1 - alpha_release;

// Target steering gains
target_kf = max(0, fb_db / max_db);
target_kb = max(0, -fb_db / max_db);
target_kl = max(0, lr_db / max_db);
target_kr = max(0, -lr_db / max_db);

mode = slider6;
(mode == 1) ? target_kb = 0;

// Asymmetric smooth gains (attack fixed, release adaptive)
(target_kf > kf_smooth) ? (
  kf_smooth = alpha_attack * kf_smooth + beta_attack * target_kf;
) : (
  kf_smooth = alpha_release * kf_smooth + beta_release * target_kf;
);

(target_kb > kb_smooth) ? (
  kb_smooth = alpha_attack * kb_smooth + beta_attack * target_kb;
) : (
  kb_smooth = alpha_release * kb_smooth + beta_release * target_kb;
);

(target_kl > kl_smooth) ? (
  kl_smooth = alpha_attack * kl_smooth + beta_attack * target_kl;
) : (
  kl_smooth = alpha_release * kl_smooth + beta_release * target_kl;
);

(target_kr > kr_smooth) ? (
  kr_smooth = alpha_attack * kr_smooth + beta_attack * target_kr;
) : (
  kr_smooth = alpha_release * kr_smooth + beta_release * target_kr;
);

// Mid outputs
FL_mid = L_mid - 0.16 * R_mid + 0.16 * kr_smooth * R_mid - 0.58 * kb_smooth * (L_mid - R_mid) - 0.42 * kf_smooth * (L_mid + R_mid);
FR_mid = R_mid - 0.16 * L_mid + 0.16 * kl_smooth * L_mid + 0.58 * kb_smooth * (L_mid - R_mid) - 0.42 * kf_smooth * (L_mid + R_mid);
FC_mid = 0.5 * (L_mid + R_mid) - 0.5 * kl_smooth * L_mid - 0.5 * kr_smooth * R_mid + 0.205 * kf_smooth * (L_mid + R_mid);
S_mid = 0.5 * (L_mid - R_mid) - 0.5 * kl_smooth * L_mid + 0.5 * kr_smooth * R_mid + 0.205 * kb_smooth * (L_mid - R_mid);

// Final before surround processing
FL = FL_low + FL_mid;
FR = FR_low + FR_mid;
FC = FC_low + FC_mid;
S = S_low + S_mid;

(mode == 1) ? S = 0 : (
  // Surround lowpass
  S_lp = a0s * S + a1s * s_lp_x1 + a2s * s_lp_x2 - b1s * s_lp_y1 - b2s * s_lp_y2;
  s_lp_x2 = s_lp_x1; s_lp_x1 = S;
  s_lp_y2 = s_lp_y1; s_lp_y1 = S_lp;
  S = S_lp;

  // Delay guard: only use circular buffer when delay_samples > 0
S_delayed = S;
(delay_samples > 0) ? (
  S_delayed = m[delay_pos];
  m[delay_pos] = S;
  delay_pos += 1;
  (delay_pos >= delay_samples) ? delay_pos = 0;
);
S = S_delayed;
);

// Output gain
FL *= gain_out;
FR *= gain_out;
FC *= gain_out;
LS = S * surround_level * gain_out;
RS = S * surround_level * gain_out;

// Output levels
(slider10 == 1) ? (
  fl_level = alpha_out * fl_level + beta_out * abs(FL);
  fr_level = alpha_out * fr_level + beta_out * abs(FR);
  fc_level = alpha_out * fc_level + beta_out * abs(FC);
  s_level_out = alpha_out * s_level_out + beta_out * abs(LS);
);

// Soft clip
FL = softclip(FL);
FR = softclip(FR);
FC = softclip(FC);
LS = softclip(LS);
RS = softclip(RS);

// 5.1 output
spl0 = FL;
spl1 = FR;
spl2 = FC;
spl3 = 0; // LFE
spl4 = LS;
spl5 = RS;

@gfx 640 240

// Always clear the background to prevent leftover graphics when toggled off
gfx_set(0.1, 0.1, 0.1, 1);
gfx_rect(0, 0, gfx_w, gfx_h);

// Only draw the meters and plot if the GUI is toggled 'On'
(slider10 == 1) ? (

  // Output levels (FL, FR, C, S) as vertical meters
  bar_w = 40;
  bar_h = gfx_h - 40;
  margin = 20;
  space = 20;
  x_pos = margin;
  
  db_min = -60;
  db_max = 0;
  
  // FL
  db_fl = 20 * log10(fl_level + 0.000000000001);
  height_fl = max(0, (db_fl - db_min) / (db_max - db_min)) * bar_h;
  gfx_set(0, 1, 0, 1);
  gfx_rect(x_pos, gfx_h - 20 - height_fl, bar_w, height_fl);
  gfx_set(1, 1, 1, 1);
  gfx_x = x_pos + 10; gfx_y = gfx_h - 15;
  gfx_drawstr("FL");
  x_pos += bar_w + space;
  
  // FR
  db_fr = 20 * log10(fr_level + 0.000000000001);
  height_fr = max(0, (db_fr - db_min) / (db_max - db_min)) * bar_h;
  gfx_set(0, 1, 0, 1);
  gfx_rect(x_pos, gfx_h - 20 - height_fr, bar_w, height_fr);
  gfx_set(1, 1, 1, 1);
  gfx_x = x_pos + 10; gfx_y = gfx_h - 15;
  gfx_drawstr("FR");
  x_pos += bar_w + space;
  
  // C
  db_fc = 20 * log10(fc_level + 0.000000000001);
  height_fc = max(0, (db_fc - db_min) / (db_max - db_min)) * bar_h;
  gfx_set(0, 1, 0, 1);
  gfx_rect(x_pos, gfx_h - 20 - height_fc, bar_w, height_fc);
  gfx_set(1, 1, 1, 1);
  gfx_x = x_pos + 10; gfx_y = gfx_h - 15;
  gfx_drawstr("C");
  x_pos += bar_w + space;
  
  // S
  db_s_out = 20 * log10(s_level_out + 0.000000000001);
  height_s = max(0, (db_s_out - db_min) / (db_max - db_min)) * bar_h;
  gfx_set(0, 1, 0, 1);
  gfx_rect(x_pos, gfx_h - 20 - height_s, bar_w, height_s);
  gfx_set(1, 1, 1, 1);
  gfx_x = x_pos + 10; gfx_y = gfx_h - 15;
  gfx_drawstr("S");
  x_pos += bar_w + space;
  
  // Dominant signal on X,Y axis
  plot_size = min(gfx_h - 65, gfx_w - x_pos - margin);
  center_x = x_pos + plot_size / 2;
  center_y = (gfx_h - 20) / 2 + 20; // Center vertically, accounting for labels
  
  // Draw axes
  gfx_set(1, 1, 1, 0.2);
  gfx_line(center_x - plot_size/2, center_y, center_x + plot_size/2, center_y); // X axis
  gfx_line(center_x, center_y - plot_size/2, center_x, center_y + plot_size/2); // Y axis
  
  // Labels
  gfx_set(1, 1, 1, 1);
  gfx_x = center_x - plot_size/2 - 15; gfx_y = center_y - 5;
  gfx_drawstr("L");
  gfx_x = center_x + plot_size/2 + 7; gfx_y = center_y - 5;
  gfx_drawstr("R");
  gfx_x = center_x - 5; gfx_y = center_y - plot_size/2 - 15;
  gfx_drawstr("F");
  gfx_x = center_x - 5; gfx_y = center_y + plot_size/2 + 7;
  gfx_drawstr("B");
  
  // Plot point
  lr_norm = lr_db / max_db;
  fb_norm = fb_db / max_db;
  half = plot_size / 2;
  pos_x = center_x - lr_norm * half;
  pos_y = center_y - fb_norm * half;
  
  gfx_set(1, 0, 0, 1);
  gfx_circle(pos_x, pos_y, 5, 1, 1);
  
  // Title
  gfx_x = x_pos; gfx_y = 10;
  gfx_drawstr("Steering Direction");

); // End of the check for (slider10 == 1)

